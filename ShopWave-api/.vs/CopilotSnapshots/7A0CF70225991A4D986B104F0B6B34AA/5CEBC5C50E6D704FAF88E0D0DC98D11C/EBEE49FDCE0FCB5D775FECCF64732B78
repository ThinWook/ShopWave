using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using ShopWave.Models;
using ShopWave.Models.DTOs;
using ShopWave.Models.Responses;
using System.ComponentModel.DataAnnotations;

namespace ShopWave.Controllers
{
    [ApiController]
    [Route("api/v1/[controller]")]
    public class WishlistController : ControllerBase
    {
        private readonly ShopWaveDbContext _context;
        private readonly ILogger<WishlistController> _logger;

        public WishlistController(ShopWaveDbContext context, ILogger<WishlistController> logger)
        {
            _context = context;
            _logger = logger;
        }

        [HttpGet]
        public async Task<IActionResult> GetWishlist([FromQuery] int page = 1, [FromQuery] int pageSize = 12, [FromHeader(Name = "Authorization")] string? token = null)
        {
            Guid? userId = null;
            try
            {
                userId = await GetUserIdFromToken(token);
                if (userId == null) return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));
                if (page < 1) page = 1; if (pageSize <= 0 || pageSize > 100) pageSize = 12;

                var baseQuery = _context.WishlistItems.Include(wi => wi.Product).ThenInclude(p => p.Category)
                    .Where(wi => wi.UserId == userId.Value && wi.Product.IsActive).OrderByDescending(wi => wi.CreatedAt);
                var total = await baseQuery.CountAsync();
                var totalPages = total == 0 ? 0 : (int)Math.Ceiling(total / (double)pageSize);
                if (totalPages > 0 && page > totalPages) page = totalPages;

                var list = await baseQuery.Skip((page - 1) * pageSize).Take(pageSize).Select(wi => new WishlistItemDto
                {
                    Id = wi.Id,
                    ProductId = wi.ProductId,
                    ProductName = wi.Product.Name,
                    ProductPrice = wi.Product.Price,
                    ProductImageUrl = wi.Product.ImageUrl,
                    ProductRating = wi.Product.Rating,
                    ProductStockQuantity = wi.Product.StockQuantity,
                    CategoryName = wi.Product.Category.Name,
                    AddedAt = wi.CreatedAt
                }).ToListAsync();

                var paged = new PagedResult<WishlistItemDto>(
                    Data: list,
                    CurrentPage: page,
                    TotalPages: totalPages,
                    PageSize: pageSize,
                    TotalRecords: total,
                    HasPreviousPage: page > 1,
                    HasNextPage: page < totalPages,
                    AppliedFilters: new { }
                );
                return Ok(EnvelopeBuilder.Ok(HttpContext, "WISHLIST_RETRIEVED", paged));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving wishlist {UserId}", userId);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpPost]
        public async Task<IActionResult> AddToWishlist([FromBody] AddToWishlistRequest request, [FromHeader(Name = "Authorization")] string? token)
        {
            Guid? userId = null;
            try
            {
                userId = await GetUserIdFromToken(token);
                if (userId == null) return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));

                var product = await _context.Products.FindAsync(request.ProductId);
                if (product == null || !product.IsActive)
                {
                    return NotFound(EnvelopeBuilder.Fail<object>(HttpContext, "NOT_FOUND", new[] { new ErrorItem("product", "Product not found", "NOT_FOUND") }, 404));
                }

                var existing = await _context.WishlistItems.FirstOrDefaultAsync(wi => wi.UserId == userId.Value && wi.ProductId == request.ProductId);
                if (existing != null)
                {
                    return Conflict(EnvelopeBuilder.Fail<object>(HttpContext, "ALREADY_EXISTS", new[] { new ErrorItem("wishlist", "Already in wishlist", "ALREADY_EXISTS") }, 409));
                }

                var item = new WishlistItem { UserId = userId.Value, ProductId = request.ProductId, CreatedAt = DateTime.UtcNow };
                _context.WishlistItems.Add(item);
                await _context.SaveChangesAsync();
                return StatusCode(201, EnvelopeBuilder.Ok(HttpContext, "WISHLIST_ITEM_ADDED", new { id = item.Id }));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding wishlist item {ProductId} for {UserId}", request.ProductId, userId);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpDelete("{productId}")]
        public async Task<IActionResult> RemoveFromWishlist(Guid productId, [FromHeader(Name = "Authorization")] string? token)
        {
            Guid? userId = null;
            try
            {
                userId = await GetUserIdFromToken(token);
                if (userId == null) return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));

                var item = await _context.WishlistItems.FirstOrDefaultAsync(wi => wi.UserId == userId.Value && wi.ProductId == productId);
                if (item == null)
                {
                    return NotFound(EnvelopeBuilder.Fail<object>(HttpContext, "NOT_FOUND", new[] { new ErrorItem("productId", "Wishlist item not found", "NOT_FOUND") }, 404));
                }
                _context.WishlistItems.Remove(item);
                await _context.SaveChangesAsync();
                return Ok(EnvelopeBuilder.Ok(HttpContext, "WISHLIST_ITEM_REMOVED", new { }));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error removing wishlist item {ProductId} for {UserId}", productId, userId);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpGet("check/{productId}")]
        public async Task<IActionResult> CheckInWishlist(Guid productId, [FromHeader(Name = "Authorization")] string? token)
        {
            Guid? userId = null;
            try
            {
                userId = await GetUserIdFromToken(token);
                if (userId == null)
                {
                    return Ok(EnvelopeBuilder.Ok(HttpContext, "WISHLIST_CHECK", new { inWishlist = false }));
                }

                var exists = await _context.WishlistItems.AnyAsync(wi => wi.UserId == userId.Value && wi.ProductId == productId);
                return Ok(EnvelopeBuilder.Ok(HttpContext, "WISHLIST_CHECK", new { inWishlist = exists }));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking wishlist item {ProductId} for {UserId}", productId, userId);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpDelete("clear")]
        public async Task<IActionResult> ClearWishlist([FromHeader(Name = "Authorization")] string? token)
        {
            Guid? userId = null;
            try
            {
                userId = await GetUserIdFromToken(token);
                if (userId == null) return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));

                var items = await _context.WishlistItems.Where(wi => wi.UserId == userId.Value).ToListAsync();
                if (items.Count > 0)
                {
                    _context.WishlistItems.RemoveRange(items);
                    await _context.SaveChangesAsync();
                }
                return Ok(EnvelopeBuilder.Ok(HttpContext, "WISHLIST_CLEARED", new { }));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error clearing wishlist {UserId}", userId);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpPost("move-to-cart/{productId}")]
        public async Task<IActionResult> MoveToCart(Guid productId, [FromHeader(Name = "Authorization")] string? token)
        {
            Guid? userId = null;
            try
            {
                userId = await GetUserIdFromToken(token);
                if (userId == null) return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));

                var wishlistItem = await _context.WishlistItems.Include(w => w.Product)
                    .FirstOrDefaultAsync(w => w.UserId == userId.Value && w.ProductId == productId);
                if (wishlistItem == null)
                {
                    return NotFound(EnvelopeBuilder.Fail<object>(HttpContext, "NOT_FOUND", new[] { new ErrorItem("productId", "Wishlist item not found", "NOT_FOUND") }, 404));
                }
                if (wishlistItem.Product.StockQuantity <= 0)
                {
                    return BadRequest(EnvelopeBuilder.Fail<object>(HttpContext, "OUT_OF_STOCK", new[] { new ErrorItem("stock", "Product out of stock", "OUT_OF_STOCK") }, 400));
                }

                var cartItem = await _context.CartItems.FirstOrDefaultAsync(ci => ci.UserId == userId.Value && ci.ProductId == productId);
                if (cartItem != null)
                {
                    cartItem.Quantity += 1;
                    cartItem.UpdatedAt = DateTime.UtcNow;
                }
                else
                {
                    cartItem = new CartItem { UserId = userId.Value, ProductId = productId, Quantity = 1, UnitPrice = wishlistItem.Product.Price, CreatedAt = DateTime.UtcNow, UpdatedAt = DateTime.UtcNow };
                    _context.CartItems.Add(cartItem);
                }
                _context.WishlistItems.Remove(wishlistItem);
                await _context.SaveChangesAsync();

                return Ok(EnvelopeBuilder.Ok(HttpContext, "WISHLIST_ITEM_MOVED_TO_CART", new { }));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error moving wishlist item {ProductId} to cart for {UserId}", productId, userId);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        private async Task<Guid?> GetUserIdFromToken(string? token)
        {
            if (string.IsNullOrEmpty(token)) return null;
            token = token.Replace("Bearer ", "");
            var session = await _context.UserSessions.FirstOrDefaultAsync(s => s.SessionToken == token && s.ExpiresAt > DateTime.UtcNow);
            return session?.UserId;
        }
    }

    public class AddToWishlistRequest
    {
        [Required] public Guid ProductId { get; set; }
    }

    public class WishlistItemDto
    {
        public Guid Id { get; set; }
        public Guid ProductId { get; set; }
        public string ProductName { get; set; } = string.Empty;
        public decimal ProductPrice { get; set; }
        public string? ProductImageUrl { get; set; }
        public double ProductRating { get; set; }
        public int ProductStockQuantity { get; set; }
        public string CategoryName { get; set; } = string.Empty;
        public DateTime AddedAt { get; set; }
    }
}