using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using ShopWave.Models;
using ShopWave.Models.DTOs;
using ShopWave.Models.Responses;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;

namespace ShopWave.Controllers
{
    [ApiController]
    [Route("api/v1/[controller]")]
    [Authorize]
    public class OrdersController : ControllerBase
    {
        private readonly ShopWaveDbContext _context;
        private readonly ILogger<OrdersController> _logger;

        public OrdersController(ShopWaveDbContext context, ILogger<OrdersController> logger)
        {
            _context = context;
            _logger = logger;
        }

        [HttpPost]
        public async Task<IActionResult> CreateOrder([FromBody] CreateOrderRequest request)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var uid = User.FindFirstValue("uid") ?? User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(JwtRegisteredClaimNames.Sub);
                if (!Guid.TryParse(uid, out var userId))
                {
                    return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));
                }

                var cartItems = await _context.CartItems
                    .Include(ci => ci.Product)
                    .Where(ci => ci.UserId == userId)
                    .ToListAsync();

                if (!cartItems.Any())
                {
                    return BadRequest(EnvelopeBuilder.Fail<object>(HttpContext, "CART_EMPTY", new[] { new ErrorItem("cart", "Cart is empty", "CART_EMPTY") }, 400));
                }

                // Check availability by summing variant stocks per product
                var productIds = cartItems.Select(ci => ci.ProductId).Distinct().ToList();
                var variants = await _context.ProductVariants.Where(v => productIds.Contains(v.ProductId)).OrderBy(v => v.Price).ToListAsync();

                foreach (var cartItem in cartItems)
                {
                    var totalStock = variants.Where(v => v.ProductId == cartItem.ProductId).Sum(v => v.Stock);
                    if (totalStock < cartItem.Quantity)
                    {
                        return BadRequest(EnvelopeBuilder.Fail<object>(HttpContext, "OUT_OF_STOCK", new[] { new ErrorItem("product", $"Insufficient stock for '{cartItem.Product.Name}'", "OUT_OF_STOCK") }, 400));
                    }
                }

                var subTotal = cartItems.Sum(ci => ci.Quantity * ci.UnitPrice);
                var shippingFee = CalculateShippingFee(subTotal);
                var totalAmount = subTotal + shippingFee;
                var orderNumber = await GenerateOrderNumber();

                var order = new Order
                {
                    UserId = userId,
                    OrderNumber = orderNumber,
                    TotalAmount = totalAmount,
                    Status = "Pending",
                    ShippingAddress = JsonSerializer.Serialize(request.ShippingAddress),
                    BillingAddress = request.BillingAddress != null ? JsonSerializer.Serialize(request.BillingAddress) : null,
                    PaymentMethod = request.PaymentMethod,
                    PaymentStatus = "Pending",
                    OrderDate = DateTime.UtcNow,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };

                _context.Orders.Add(order);
                await _context.SaveChangesAsync();

                var orderItems = new List<OrderItem>();
                foreach (var cartItem in cartItems)
                {
                    var orderItem = new OrderItem
                    {
                        OrderId = order.Id,
                        ProductId = cartItem.ProductId,
                        ProductName = cartItem.Product.Name,
                        Quantity = cartItem.Quantity,
                        UnitPrice = cartItem.UnitPrice,
                        TotalPrice = cartItem.Quantity * cartItem.UnitPrice,
                        CreatedAt = DateTime.UtcNow
                    };
                    orderItems.Add(orderItem);

                    // Allocate stock from variants (cheapest-first)
                    var productVariants = variants.Where(v => v.ProductId == cartItem.ProductId).OrderBy(v => v.Price).ToList();
                    var remaining = cartItem.Quantity;
                    foreach (var v in productVariants)
                    {
                        if (remaining <= 0) break;
                        var deduct = Math.Min(remaining, v.Stock);
                        v.Stock -= deduct;
                        remaining -= deduct;
                    }
                }
                _context.OrderItems.AddRange(orderItems);
                _context.CartItems.RemoveRange(cartItems);

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                var response = new OrderResponse
                {
                    OrderId = order.Id,
                    OrderNumber = order.OrderNumber,
                    TotalAmount = order.TotalAmount,
                    Status = order.Status,
                    OrderDate = order.OrderDate,
                    OrderItems = orderItems.Select(oi => new OrderItemDto
                    {
                        Id = oi.Id,
                        ProductName = oi.ProductName,
                        Quantity = oi.Quantity,
                        UnitPrice = oi.UnitPrice,
                        TotalPrice = oi.TotalPrice
                    }).ToList()
                };

                return StatusCode(201, EnvelopeBuilder.Ok(HttpContext, "ORDER_CREATED", response));
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                _logger.LogError(ex, "Error creating order");
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpGet]
        public async Task<IActionResult> GetMyOrders([FromQuery] int page = 1, [FromQuery] int pageSize = 10, [FromQuery] string? status = null)
        {
            try
            {
                var uid = User.FindFirstValue("uid") ?? User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(JwtRegisteredClaimNames.Sub);
                if (!Guid.TryParse(uid, out var userId))
                {
                    return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));
                }
                if (page < 1) page = 1;
                if (pageSize <= 0 || pageSize > 100) pageSize = 10;

                var query = _context.Orders.Where(o => o.UserId == userId);
                if (!string.IsNullOrWhiteSpace(status)) query = query.Where(o => o.Status == status);

                var total = await query.CountAsync();
                var totalPages = total == 0 ? 0 : (int)Math.Ceiling(total / (double)pageSize);
                if (totalPages > 0 && page > totalPages) page = totalPages;

                var orders = await query
                    .OrderByDescending(o => o.CreatedAt)
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .Select(o => new OrderDto
                    {
                        Id = o.Id,
                        OrderNumber = o.OrderNumber,
                        TotalAmount = o.TotalAmount,
                        Status = o.Status,
                        PaymentStatus = o.PaymentStatus,
                        OrderDate = o.OrderDate,
                        ShippedDate = o.ShippedDate,
                        DeliveredDate = o.DeliveredDate,
                        OrderItems = o.OrderItems.Select(oi => new OrderItemDto
                        {
                            Id = oi.Id,
                            ProductName = oi.ProductName,
                            Quantity = oi.Quantity,
                            UnitPrice = oi.UnitPrice,
                            TotalPrice = oi.TotalPrice
                        }).ToList()
                    })
                    .ToListAsync();

                var paged = new PagedResult<OrderDto>(
                    Data: orders,
                    CurrentPage: page,
                    TotalPages: totalPages,
                    PageSize: pageSize,
                    TotalRecords: total,
                    HasPreviousPage: page > 1,
                    HasNextPage: page < totalPages,
                    AppliedFilters: new { status }
                );

                return Ok(EnvelopeBuilder.Ok(HttpContext, "ORDER_LIST_RETRIEVED", paged));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving orders");
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> GetOrderById(Guid id)
        {
            try
            {
                var uid = User.FindFirstValue("uid") ?? User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(JwtRegisteredClaimNames.Sub);
                if (!Guid.TryParse(uid, out var userId))
                {
                    return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));
                }

                var user = await _context.Users.FindAsync(userId);
                var order = await _context.Orders.Include(o => o.OrderItems).FirstOrDefaultAsync(o => o.Id == id);
                if (order == null)
                {
                    return NotFound(EnvelopeBuilder.Fail<object>(HttpContext, "NOT_FOUND", new[] { new ErrorItem("id", "Order not found", "NOT_FOUND") }, 404));
                }
                if (order.UserId != userId && user?.Role != "Admin")
                {
                    return StatusCode(403, EnvelopeBuilder.Fail<object>(HttpContext, "FORBIDDEN", new[] { new ErrorItem("auth", "Forbidden", "FORBIDDEN") }, 403));
                }

                var detail = new OrderDetailDto
                {
                    Id = order.Id,
                    OrderNumber = order.OrderNumber,
                    TotalAmount = order.TotalAmount,
                    Status = order.Status,
                    PaymentMethod = order.PaymentMethod,
                    PaymentStatus = order.PaymentStatus,
                    OrderDate = order.OrderDate,
                    ShippedDate = order.ShippedDate,
                    DeliveredDate = order.DeliveredDate,
                    ShippingAddress = order.ShippingAddress,
                    BillingAddress = order.BillingAddress,
                    OrderItems = order.OrderItems.Select(oi => new OrderItemDto
                    {
                        Id = oi.Id,
                        ProductName = oi.ProductName,
                        Quantity = oi.Quantity,
                        UnitPrice = oi.UnitPrice,
                        TotalPrice = oi.TotalPrice
                    }).ToList()
                };

                return Ok(EnvelopeBuilder.Ok(HttpContext, "ORDER_DETAIL_RETRIEVED", detail));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving order {OrderId}", id);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        [HttpPut("{id}/cancel")]
        public async Task<IActionResult> CancelOrder(Guid id)
        {
            try
            {
                var uid = User.FindFirstValue("uid") ?? User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue(JwtRegisteredClaimNames.Sub);
                if (!Guid.TryParse(uid, out var userId))
                {
                    return Unauthorized(EnvelopeBuilder.Fail<object>(HttpContext, "UNAUTHORIZED", new[] { new ErrorItem("auth", "Unauthorized", "UNAUTHORIZED") }, 401));
                }

                var order = await _context.Orders
                    .Include(o => o.OrderItems)
                    .FirstOrDefaultAsync(o => o.Id == id && o.UserId == userId);
                if (order == null)
                {
                    return NotFound(EnvelopeBuilder.Fail<object>(HttpContext, "NOT_FOUND", new[] { new ErrorItem("id", "Order not found", "NOT_FOUND") }, 404));
                }
                if (order.Status != "Pending" && order.Status != "Processing")
                {
                    return BadRequest(EnvelopeBuilder.Fail<object>(HttpContext, "INVALID_STATE", new[] { new ErrorItem("status", "Order cannot be cancelled in current state", "INVALID_STATE") }, 400));
                }

                // Return stock to variants: add back to variants in order they were deducted (we'll add to cheapest-first)
                var productIds = order.OrderItems.Select(oi => oi.ProductId).Distinct().ToList();
                var variants = await _context.ProductVariants.Where(v => productIds.Contains(v.ProductId)).OrderBy(v => v.Price).ToListAsync();

                foreach (var orderItem in order.OrderItems)
                {
                    var remaining = orderItem.Quantity;
                    var productVariants = variants.Where(v => v.ProductId == orderItem.ProductId).OrderBy(v => v.Price).ToList();
                    foreach (var v in productVariants)
                    {
                        if (remaining <= 0) break;
                        // Return stock proportionally: we'll just add back to the first variants until quantity filled
                        var add = Math.Min(remaining, int.MaxValue);
                        v.Stock += add;
                        remaining -= add;
                    }
                }
                order.Status = "Cancelled";
                order.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();

                return Ok(EnvelopeBuilder.Ok(HttpContext, "ORDER_CANCELLED", new { }));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cancelling order {OrderId}", id);
                return StatusCode(500, EnvelopeBuilder.Fail<object>(HttpContext, "INTERNAL_ERROR", new[] { new ErrorItem("server", "Unexpected error", "INTERNAL_ERROR") }, 500));
            }
        }

        private decimal CalculateShippingFee(decimal subTotal) => subTotal >= 500000 ? 0 : 30000;

        private async Task<string> GenerateOrderNumber()
        {
            var today = DateTime.UtcNow.ToString("yyyyMMdd");
            var lastOrder = await _context.Orders.Where(o => o.OrderNumber.StartsWith($"ORD{today}") )
                .OrderByDescending(o => o.OrderNumber).FirstOrDefaultAsync();
            var seq = 1;
            if (lastOrder != null)
            {
                var tail = lastOrder.OrderNumber.Substring(11);
                if (int.TryParse(tail, out var parsed)) seq = parsed + 1;
            }
            return $"ORD{today}{seq:D4}";
        }
    }

    public class CreateOrderRequest
    {
        [Required]
        public AddressDto ShippingAddress { get; set; } = null!;
        public AddressDto? BillingAddress { get; set; }
        [Required]
        [MaxLength(100)]
        public string PaymentMethod { get; set; } = string.Empty;
        public string? Notes { get; set; }
    }

    public class AddressDto
    {
        [Required] public string FullName { get; set; } = string.Empty;
        [Required] public string Phone { get; set; } = string.Empty;
        [Required] public string Address { get; set; } = string.Empty;
        [Required] public string Ward { get; set; } = string.Empty;
        [Required] public string District { get; set; } = string.Empty;
        [Required] public string City { get; set; } = string.Empty;
        public string? Notes { get; set; }
    }

    public class OrderDetailDto : OrderDto
    {
        public string? PaymentMethod { get; set; }
        public string? ShippingAddress { get; set; }
        public string? BillingAddress { get; set; }
    }
}